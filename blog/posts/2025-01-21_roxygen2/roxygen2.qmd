---
title: "DocumentaciÃ³n de funciones con roxygen2"
format: html
date: '2023-08-09'
categories: ['R', 'roxygen2', 'Tutorial']
---

# DocumentaciÃ³n de funciones

Documentar las funciones en R es esencial para garantizar que el cÃ³digo sea comprensible, reutilizable y mantenible. En este tutorial vamos a mostrar los pasos sencillos de documentar las funciones de un paquete con roxygen2.

## Diapositivas


```{r,echo=FALSE}
knitr::include_url("https://comunidadbioinfo.github.io/cdsb2023/Documentacion_slides_03_sesion5.html", height = "380px")
```
[link](https://comunidadbioinfo.github.io/cdsb2023/Documentacion_slides_03_sesion5.html)


## Links importantes:

Esta lecciÃ³n estÃ¡ basada en algunos manuales sobre documentaciÃ³n:

+  [Una viÃ±eta del cranproject](https://cran.r-project.org/web/packages/roxygen2/vignettes/rd.html)
+  [El manual de paqutes de r](https://r-pkgs.org/man.html#sec-man-key-md-features)
+  [En esta viÃ±eta de cranproject](https://combine-australia.github.io/r-pkg-dev/documenting-functions.html)

## Â¿QuÃ© es la documentaciÃ³n de una funciÃ³n y por quÃ© es importante?

1.  ğŸ™‡ï¸ Es la informaciÃ³n complementaria que el desarrollador escribe sobre una
funciÃ³n y que se accede con `?` seguido el nombre de una funciÃ³n actual de un
paquete p.ej. `?unafuncion`.

2.  ğŸ“ La documentaciÃ³n se almacena como un archivo .Rd ("R documentation) en la
carpeta `man/`.

3.  ğŸ” La documentaciÃ³n usa una sÃ­ntesis especial, que es distinta a la de r y 
que estÃ¡ ligeramente basada en LaTeX.

4.  ğŸ“„ Se puede renderizar como html, pdf o texto sin formato segÃºn se necesite.

## Generacion de la documentacion con ayuda del paquete roxygen

En un paquete de r y en cualquier ecosistema de devtools no editamos un 
documento `.Rd` manualmente. La documentaciÃ³n usa una sÃ­ntesis parecida a LaTex 
que puede ser fÃ¡cil de estropear. Por ventaja existen paquetes como roxigen2. 
Usar roxigen nos permite usar comentarios especiales sobre el inicio de la
funciÃ³n, esto nos da un par de ventajas:

1.  âœ… La documentaciÃ³n y la funciÃ³n estarÃ¡n en un mismo lugar, por lo que si 
editas la funciÃ³n serÃ¡ mas fÃ¡cil recordar actualizar la documentcion tambiÃ©n.
2.  ğŸ‰ Puedes usar markdown en lugar de la sÃ­ntesis especial para los archivos
``.Rd``

## Antes de empezar...âœï¸

Vamos a crear un funciÃ³n para nuestro paquete. Supongamos que para nuestro 
paquete necesitamos una funciÃ³n que calcule la moda. Esta es una forma sencilla 
de calcular la moda:

```{r, fig.align='center'}
getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

* ``unique(serievector)``: Crea un vector que contiene Ãºnicamente los valores Ãºnicos 
de la serie de nÃºmeros serievector.
+ ``match(serievector, uniqv)``: Encuentra la posiciÃ³n de cada valor de serievector 
en el vector Ãºnico uniqv.
+ ``tabulate(match(serievector, uniqv))``: Cuenta cuÃ¡ntas veces aparece cada valor en
la serie serievector.
* ``which.max(tabulate(match(serievector, uniqv)))``: Encuentra el Ã­ndice del valor 
mÃ¡ximo en el vector de frecuencias.
+ ``uniqv[which.max(tabulate(match(serievector, uniqv)))]``: Devuelve el valor 
correspondiente al Ã­ndice calculado, que es la moda.

Creamos un ejemplo para ver que funcione:

```{r, fig.align='center'}
serie_numeros <- c(1, 2, 2, 2, 2, 3, 3, 4, 4, 4)
resultado <- getmode(serie_numeros)
print(resultado)
```
Bien ahora si podemos podemos empezar a usar el paquete de roxygen para documentar nuestra funciÃ³n.. comencemos.

## Generacion de un bloque de documentacion con ayuda del paquete roxygen.

Podemos insertar un esqueleto de comentarios de roxygen para ver su sÃ­ntesis. Colocamos el cursor en algÃºn lugar de la definiciÃ³n de nuestra funciÃ³n y buscamos en la pestaÃ±a CÃ³digo > Insertar Roxygen Skeleton.

```{r, fig.align='center'}
#' Title
#'
#' @param serievector 
#'
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```


Ahora ya tenemos un esqueleto de la documentaciÃ³n que nos da una ventaja para su creaciÃ³n.
Las lÃ­neas de comentarios de Roxygen siempre comienzan con ``#'``, el habitual para un comentario ``#`` mas un ``'``

Veamos los comentarios de uno por uno:

Empezamos con el titulo. Se sugiere poner en el titulo las acciones principales que realiza la funciÃ³n en este caso por ejemplo podremos usar:

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @param serievector 
#'
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Muy bien!.
El siguiente comentario que podemos ver es ``@param``. Pero antes, vamos a aÃ±adir una pequeÃ±a descripciÃ³n de la funciÃ³n y como usarla. Primero aÃ±adimos la pequeÃ±a descripciÃ³n con ``@description``:

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' @param serievector
#'
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Ahora vamos a aÃ±adir el comentario `@usage` que nos indica como puedes mandar a llamar la funciÃ³n.

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' @usage getmode(serievector)
#' @param serievector
#'
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Ahora si vamos a aÃ±adir una pequeÃ±a descripciÃ³n de nuestros argumentos. Si tuviÃ©ramos mas de un parÃ¡metro en nuestra funciÃ³n podrÃ­amos llamar las veces que sea necesario el comentario de parÃ¡metro con ``@param``, veamoslo.

Ahora aÃ±adimos una pequeÃ±a descripciÃ³n a nuestro Ãºnico parÃ¡metro que es serievector:

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' 
#' @param serievector Es una serie de nÃºmeros en forma de  un vector simple de r.
#'
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

DespuÃ©s, podemos aÃ±adir un comentario de detalles de la funciÃ³n con ``@details``.
Por ejemplo, si en nuestro ejemplo tuviÃ©ramos ciertos valores no numÃ©ricos en nuestro vector de entrada, por ejemplo letras, Â¿nuestra funciÃ³n podrÃ­a leerlas?, o si le diÃ©ramos un vector sin caracteres Â¿que pasarÃ­a?, veamos:

```{r, fig.align='center'}
serie_numeros <- c(0,2,2,"d", "d","d")
resultado <- getmode(serie_numeros)
print(resultado)
```
```{r, fig.align='center'}
serie_numeros <- c()
resultado <- getmode(serie_numeros)
print(resultado)
```
Entonces, esto es un ejemplo de lo que podrÃ­amos poner en el comentario
``@details``. Hagamoslo describiendo esto. En details podemos agregar detalles 
un poco mas especÃ­ficos que en la descripciÃ³n de la funciÃ³n 

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' 
#' @param serievector Es una serie de nÃºmeros en forma de  un vector simple de r.
#'
#' @details si tu vector de entrada puede ser interpretado alternando nÃºmeros y 
#' letras escritas entre comillas "". Si un vector esta vacÃ­o, darÃ¡ como 
#' resultado un NULL.
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Ya casi terminamos de llenar nuestra documentaciÃ³n, pero antes vamos a ver algunos 
otros arrobas que pudieran ser importantes.
El ```@import``` e ``@importfrom`` importan funciones de otros paquetes en caso 
de que las necesitemos, el primero importa todas las funciones del paquete que
que solicites, y el segundo importa solo algunas funciones especificas. 
En nuestra funciÃ³n no necesitamos llamar funciones de otros paquetes puesto que 
todas las que usamos estÃ¡n en r base. Pero imaginemos que tu funciÃ³n, por 
ejemplo necesita leer un archivo ``.tsv`` con la funciÃ³n read_tsv del paquete 
readr y despuÃ©s reconvertir la tabla resultante en un archivo con ``write.table`` 
pero solo necesitas esa funciÃ³n del paquete ``utils``, entonces harÃ­amos:

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' 
#' @param serievector Es una serie de nÃºmeros en forma de  un vector simple de r.
#'
#' @details si tu vector de entrada puede ser interpretado alternando nÃºmeros y 
#' letras escritas entre comillas "". Si un vector esta vacÃ­o, darÃ¡ como 
#' resultado un NULL.
#' @import readr
#' @importFrom utils write.table
#' @return
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

AsÃ­ podemos importar las funciones que necesitemos de otros paquetes y se 
incluirÃ¡n en la documentaciÃ³n y se cargaran automÃ¡ticamente al cargar tu paquete.

:eyes::exclamation: Para un correcto funcionamiento de tu paquete y al estar los
paquetes necesarios incluidos en la documentaciÃ³n, no serÃ¡ necesario llamarlos 
de la forma ``library("apackage")```.

Entonces llegamos a la secciÃ³n ``@return``. Esta descripciÃ³n le servirÃ¡ al 
usuario del paquete para conocer cual sera el resultado de la funciÃ³n, que puede
ser un archivo, una tabla, un numero,etc. Entonces retomando la funciÃ³n que 
usamos al inicio, vamos a escribir una descripciÃ³n corta del resultado de la 
funciÃ³n ``getmode()``.

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' 
#' @param serievector Es una serie de nÃºmeros en forma de  un vector simple de r.
#'
#' @details si tu vector de entrada puede ser interpretado alternando nÃºmeros y 
#' letras escritas entre comillas "". Si un vector esta vacÃ­o, darÃ¡ como 
#' resultado un NULL.
#' @return El carÃ¡cter con mas frecuencia de el vector de entrada.
#' @export
#'
#' @examples

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Por ultimo tenemos ``@export`` que es el encargado de renderizar la documentaciÃ³n 
para que pueda aparecer en la ventana de Ayuda (abajo a la derecha). esta opciÃ³n la dejamos para funciones principales que el usuario va a utilizar, aunque puede que existan alguna funciones internas que no queremos que el usuario vea. En ese caso vamos a usar 
``@noRd`` en lugar de este.

Antes de terminar podemos incluir ejemplos de como funciona nuestra funciÃ³n para
un mejor entendimiento, pongamos los que ya realizamos:

```{r, fig.align='center'}
#' @title Encontrar la Moda de una Serie de NÃºmeros
#'
#' @description Esta funciÃ³n lee una serie de nÃºmeros en forma de vector y
#' encuentra el elemento que mas se repite, es decir la moda.
#' 
#' @param serievector Es una serie de nÃºmeros en forma de  un vector simple de r.
#'
#' @details si tu vector de entrada puede ser interpretado alternando nÃºmeros y 
#' letras escritas entre comillas "". Si un vector esta vacÃ­o, darÃ¡ como 
#' resultado un NULL.
#' @return El carÃ¡cter con mas frecuencia de el vector de entrada.
#' @export
#'
#' @examples
#' serie_nÃºmeros <- c(1, 2, 2, 2, 2, 3, 3, 4, 4, 4)
#' resultado <- getmode(serie_nÃºmeros)
#' print(resultado)

getmode <- function(serievector) {
  uniqv <- unique(serievector)
  uniqv[which.max(tabulate(match(serievector, uniqv)))]
}
```

Ahora si, una vez teniendo listo el bloque de comentarios para la documentaciÃ³n, vamos a ejecutar ``devtools::load_all()`` para cargar nuestras funciones y hecho esto, ejecutamos
 ``devtools::document()`` o presionamos  Ctrl/Cmd + Shift + D  para convertir los comentarios en archivo ``.Rd`` y poder renderizarlo.

ğŸ’¯ Listo, tenemos nuestra documentaciÃ³n para una funciÃ³n. AsÃ­ se verÃ¡ cuando el paquete estÃ© terminado.

## Otros campos de la documentacion.

+ ``@seealso`` para indicar funciones relacionadas y facilitar la bÃºsqueda de funciones.

+ ```@references``` aÃ±ade algunas referencias.

+ ``@author`` para especificar el autor de la funciÃ³n.